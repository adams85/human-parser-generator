// DO NOT EDIT THIS FILE
// This file was generated using the Human Parser Generator
// (https://github.com/christophevg/human-parser-generator)
// on Wednesday, 27 September 2017 at 11:48:44
// Source: d:\hpg.bnf

using System;
using System.IO;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Linq;

#region Syntax Tree
// grammar ::= { rule } ;
public class Grammar : ISyntaxNode
{
    public List<Rule> Rules { get; set; } = new List<Rule>();
}

// rule ::= identifier ( _ @ "::=" | _ @ "=" ) expression ";" ;
public class Rule : ISyntaxNode
{
    public string Identifier { get; set; }
    public Expression Expression { get; set; }
}

// expression ::= sequential-expression | non-sequential-expression ;
public interface Expression : ISyntaxNode
{
}

// sequential-expression ::= non-sequential-expression [ _ @ "," ] expression ;
public class SequentialExpression : ISyntaxNode, Expression
{
    public NonSequentialExpression NonSequentialExpression { get; set; }
    public Expression Expression { get; set; }
}

// non-sequential-expression ::= alternatives-expression | atomic-expression ;
public interface NonSequentialExpression : ISyntaxNode, Expression
{
}

// alternatives-expression ::= atomic-expression "|" non-sequential-expression ;
public class AlternativesExpression : ISyntaxNode, NonSequentialExpression
{
    public AtomicExpression AtomicExpression { get; set; }
    public NonSequentialExpression NonSequentialExpression { get; set; }
}

// atomic-expression ::= nested-expression | terminal-expression ;
public interface AtomicExpression : ISyntaxNode, NonSequentialExpression
{
}

// nested-expression ::= optional-expression | repetition-expression | group-expression ;
public interface NestedExpression : ISyntaxNode, AtomicExpression
{
}

// optional-expression ::= "[" expression "]" ;
public class OptionalExpression : ISyntaxNode, NestedExpression
{
    public Expression Expression { get; set; }
}

// repetition-expression ::= "{" expression "}" ;
public class RepetitionExpression : ISyntaxNode, NestedExpression
{
    public Expression Expression { get; set; }
}

// group-expression ::= "(" expression ")" ;
public class GroupExpression : ISyntaxNode, NestedExpression
{
    public Expression Expression { get; set; }
}

// terminal-expression ::= identifier-expression | string-expression | extractor-expression ;
public interface TerminalExpression : ISyntaxNode, AtomicExpression
{
}

// identifier-expression ::= [ name ] identifier ;
public class IdentifierExpression : ISyntaxNode, TerminalExpression
{
    public string Name { get; set; }
    public string Identifier { get; set; }
}

// string-expression ::= [ name ] string ;
public class StringExpression : ISyntaxNode, TerminalExpression
{
    public string Name { get; set; }
    public string String { get; set; }
}

// extractor-expression ::= [ name ] "/" pattern "/" ;
public class ExtractorExpression : ISyntaxNode, TerminalExpression
{
    public string Name { get; set; }
    public string Pattern { get; set; }
}

// name ::= identifier "@" ;
public interface Name : ISyntaxNode
{
}

// identifier ::= /([A-Za-z_][A-Za-z0-9-_]*)/ ;
public interface Identifier : ISyntaxNode, Name
{
}

// string ::= /"([^"]*)"|^'([^']*)'/ ;
public interface String : ISyntaxNode
{
}

// pattern ::= /(.*?)(?<keep>/\s*;)/ ;
public interface Pattern : ISyntaxNode
{
}

#endregion

#region Parser
public sealed class Parser : ParserBase<Grammar>
{
    private static class Patterns
    {
        public static readonly Regex Identifier = new Regex(@"^([A-Za-z_][A-Za-z0-9-_]*)", RegexOptions.Compiled);
        public static readonly Regex String = new Regex(@"^""([^""]*)""|^'([^']*)'", RegexOptions.Compiled);
        public static readonly Regex Pattern = new Regex(@"^(.*?)(?<keep>/\s*;)", RegexOptions.Compiled);
    }

    // grammar ::= { rule } ;
    protected override void Root(Action<Grammar> onSuccess)
    {
        NonTerminal(onSuccess,
            () => Plural(
                () => _Rule(r => GetNode<Grammar>().Rules.Add(r))
            )
        );
    }

    // rule ::= identifier ( _ @ "::=" | _ @ "=" ) expression ";" ;
    private void _Rule(Action<Rule> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => Terminal(Patterns.Identifier, r => GetNode<Rule>().Identifier = r),
                () => Any(
                    () => Terminal("::="),
                    () => Terminal("=")
                ),
                () => _Expression(r => GetNode<Rule>().Expression = r),
                () => Terminal(";")
            )
        );
    }

    // expression ::= sequential-expression | non-sequential-expression ;
    private void _Expression(Action<Expression> onSuccess)
    {
        VirtualNonTerminal(onSuccess,
            () => Any(
                () => _SequentialExpression(SetNode),
                () => _NonSequentialExpression(SetNode)
            )
        );
    }

    // sequential-expression ::= non-sequential-expression [ _ @ "," ] expression ;
    private void _SequentialExpression(Action<SequentialExpression> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => _NonSequentialExpression(r => GetNode<SequentialExpression>().NonSequentialExpression = r),
                () => Optional(
                    () => Terminal(",")
                ),
                () => _Expression(r => GetNode<SequentialExpression>().Expression = r)
            )
        );
    }

    // non-sequential-expression ::= alternatives-expression | atomic-expression ;
    private void _NonSequentialExpression(Action<NonSequentialExpression> onSuccess)
    {
        VirtualNonTerminal(onSuccess,
            () => Any(
                () => _AlternativesExpression(SetNode),
                () => _AtomicExpression(SetNode)
            )
        );
    }

    // alternatives-expression ::= atomic-expression "|" non-sequential-expression ;
    private void _AlternativesExpression(Action<AlternativesExpression> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => _AtomicExpression(r => GetNode<AlternativesExpression>().AtomicExpression = r),
                () => Terminal("|"),
                () => _NonSequentialExpression(r => GetNode<AlternativesExpression>().NonSequentialExpression = r)
            )
        );
    }

    // atomic-expression ::= nested-expression | terminal-expression ;
    private void _AtomicExpression(Action<AtomicExpression> onSuccess)
    {
        VirtualNonTerminal(onSuccess,
            () => Any
            (
                () => _NestedExpression(SetNode),
                () => _TerminalExpression(SetNode)
            )
        );
    }

    // nested-expression ::= optional-expression | repetition-expression | group-expression ;
    private void _NestedExpression(Action<NestedExpression> onSuccess)
    {
        VirtualNonTerminal(onSuccess,
            () => Any(
                () => _OptionalExpression(SetNode),
                () => _RepetitionExpression(SetNode),
                () => _GroupExpression(SetNode)
            )
        );
    }

    // optional-expression ::= "[" expression "]" ;
    private void _OptionalExpression(Action<OptionalExpression> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => Terminal("["),
                () => _Expression(r => GetNode<OptionalExpression>().Expression = r),
                () => Terminal("]")
           )
        );
    }

    // repetition-expression ::= "{" expression "}" ;
    private void _RepetitionExpression(Action<RepetitionExpression> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => Terminal("{"),
                () => _Expression(r => GetNode<RepetitionExpression>().Expression = r),
                () => Terminal("}")
            )
        );
    }

    // group-expression ::= "(" expression ")" ;
    private void _GroupExpression(Action<GroupExpression> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => Terminal("("),
                () => _Expression(r => GetNode<GroupExpression>().Expression = r),
                () => Terminal(")")
            )
        );
    }

    // terminal-expression ::= identifier-expression | string-expression | extractor-expression ;
    private void _TerminalExpression(Action<TerminalExpression> onSuccess)
    {
        VirtualNonTerminal(onSuccess,
            () => Any(
                () => _IdentifierExpression(SetNode),
                () => _StringExpression(SetNode),
                () => _ExtractorExpression(SetNode)
            )
        );
    }

    // identifier-expression ::= [ name ] identifier ;
    private void _IdentifierExpression(Action<IdentifierExpression> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => Optional(
                    () => _Name(r => GetNode<IdentifierExpression>().Name = r)
                ),
                () => Terminal(Patterns.Identifier, r => GetNode<IdentifierExpression>().Identifier = r)
            )
        );
    }

    // string-expression ::= [ name ] string ;
    private void _StringExpression(Action<StringExpression> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => Optional(
                    () => _Name(r => GetNode<StringExpression>().Name = r)
                ),
                () => Terminal(Patterns.String, r => GetNode<StringExpression>().String = r)
            )
        );
    }

    // extractor-expression ::= [ name ] "/" pattern "/" ;
    private void _ExtractorExpression(Action<ExtractorExpression> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => Optional(
                    () => _Name(r => GetNode<ExtractorExpression>().Name = r)
                ),
                () => Terminal("/"),
                () => Terminal(Patterns.Pattern, r => GetNode<ExtractorExpression>().Pattern = r),
                () => Terminal("/")
            )
        );
    }

    // name ::= identifier "@" ;
    private void _Name(Action<string> onSuccess)
    {
        All(
            () => Terminal(Patterns.Identifier, onSuccess),
            () => Terminal("@")
        );
    }
}

#endregion
