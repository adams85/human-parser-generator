// DO NOT EDIT THIS FILE
// This file was generated using the Human Parser Generator
// (https://github.com/christophevg/human-parser-generator)
// on Friday, 29 September 2017 at 16:24:05
// Source: d:\hpg.bnf

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Linq;
using HumanParserGenerator;

namespace HumanParserGenerator
{
    public partial interface ISyntaxNode
    {
        void Accept(Visitor visitor);
    }
}

#region Syntax Tree
public class Grammar : ISyntaxNode
{
    public List<Rule> Rules { get; set; } = new List<Rule>();

    public void Accept(Visitor visitor)
    {
        visitor.VisitGrammar(this);
    }
}

public class Rule : ISyntaxNode
{
    public string Identifier { get; set; }
    public Expression Expression { get; set; }

    public void Accept(Visitor visitor)
    {
        visitor.VisitRule(this);
    }
}

public interface Expression : ISyntaxNode
{
}

public class SequentialExpression : ISyntaxNode, Expression
{
    public NonSequentialExpression NonSequentialExpression { get; set; }
    public Expression Expression { get; set; }

    public void Accept(Visitor visitor)
    {
        visitor.VisitSequentialExpression(this);
    }
}

public interface NonSequentialExpression : ISyntaxNode, Expression
{
}

public class AlternativesExpression : ISyntaxNode, NonSequentialExpression
{
    public AtomicExpression AtomicExpression { get; set; }
    public NonSequentialExpression NonSequentialExpression { get; set; }

    public void Accept(Visitor visitor)
    {
        visitor.VisitAlternativesExpression(this);
    }
}

public interface AtomicExpression : ISyntaxNode, NonSequentialExpression
{
}

public interface NestedExpression : ISyntaxNode, AtomicExpression
{
}

public class OptionalExpression : ISyntaxNode, NestedExpression
{
    public Expression Expression { get; set; }

    public void Accept(Visitor visitor)
    {
        visitor.VisitOptionalExpression(this);
    }
}

public class RepetitionExpression : ISyntaxNode, NestedExpression
{
    public Expression Expression { get; set; }

    public void Accept(Visitor visitor)
    {
        visitor.VisitRepetitionExpression(this);
    }
}

public class GroupExpression : ISyntaxNode, NestedExpression
{
    public Expression Expression { get; set; }

    public void Accept(Visitor visitor)
    {
        visitor.VisitGroupExpression(this);
    }
}

public interface TerminalExpression : ISyntaxNode, AtomicExpression
{
}

public class IdentifierExpression : ISyntaxNode, TerminalExpression
{
    public string Name { get; set; }
    public string Identifier { get; set; }

    public void Accept(Visitor visitor)
    {
        visitor.VisitIdentifierExpression(this);
    }
}

public class StringExpression : ISyntaxNode, TerminalExpression
{
    public string Name { get; set; }
    public string String { get; set; }

    public void Accept(Visitor visitor)
    {
        visitor.VisitStringExpression(this);
    }
}

public class ExtractorExpression : ISyntaxNode, TerminalExpression
{
    public string Name { get; set; }
    public string Pattern { get; set; }

    public void Accept(Visitor visitor)
    {
        visitor.VisitExtractorExpression(this);
    }
}

public interface Name : ISyntaxNode
{
}
#endregion

#region Parser
public sealed class Parser : ParserBase<Grammar>
{
    private static class Patterns
    {
        public static readonly Regex Identifier = new Regex(@"^([A-Za-z_][A-Za-z0-9-_]*)", RegexOptions.Compiled);
        public static readonly Regex String = new Regex(@"^""([^""]*)""|^'([^']*)'", RegexOptions.Compiled);
        public static readonly Regex Pattern = new Regex(@"^(.*?)(?<keep>/\s*;)", RegexOptions.Compiled);
    }

    // grammar ::= { rule @ rule } ;
    protected override void Root(Action<Grammar> onSuccess)
    {
        NonTerminal(onSuccess,
            () => Plural(
                () => _Rule(r => GetNode<Grammar>().Rules.Add(r))
            )
        );
    }

    // rule ::= identifier @ identifier ( _ @ "::=" | _ @ "=" ) expression @ expression ";" ;
    private void _Rule(Action<Rule> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => Terminal(Patterns.Identifier, r => GetNode<Rule>().Identifier = r),
                () => Any(
                    () => Terminal("::="),
                    () => Terminal("=")
                ),
                () => _Expression(r => GetNode<Rule>().Expression = r),
                () => Terminal(";")
            )
        );
    }

    // expression ::= sequential-expression @ sequential-expression | non-sequential-expression @ non-sequential-expression ;
    private void _Expression(Action<Expression> onSuccess)
    {
        VirtualNonTerminal(onSuccess,
            () => Any(
                () => _SequentialExpression(SetNode),
                () => _NonSequentialExpression(SetNode)
            )
        );
    }

    // sequential-expression ::= non-sequential-expression @ non-sequential-expression [ _ @ "," ] expression @ expression ;
    private void _SequentialExpression(Action<SequentialExpression> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => _NonSequentialExpression(r => GetNode<SequentialExpression>().NonSequentialExpression = r),
                () => Optional(
                    () => Terminal(",")
                ),
                () => _Expression(r => GetNode<SequentialExpression>().Expression = r)
            )
        );
    }

    // non-sequential-expression ::= alternatives-expression @ alternatives-expression | atomic-expression @ atomic-expression ;
    private void _NonSequentialExpression(Action<NonSequentialExpression> onSuccess)
    {
        VirtualNonTerminal(onSuccess,
            () => Any(
                () => _AlternativesExpression(SetNode),
                () => _AtomicExpression(SetNode)
            )
        );
    }

    // alternatives-expression ::= atomic-expression @ atomic-expression "|" non-sequential-expression @ non-sequential-expression ;
    private void _AlternativesExpression(Action<AlternativesExpression> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => _AtomicExpression(r => GetNode<AlternativesExpression>().AtomicExpression = r),
                () => Terminal("|"),
                () => _NonSequentialExpression(r => GetNode<AlternativesExpression>().NonSequentialExpression = r)
            )
        );
    }

    // atomic-expression ::= nested-expression @ nested-expression | terminal-expression @ terminal-expression ;
    private void _AtomicExpression(Action<AtomicExpression> onSuccess)
    {
        VirtualNonTerminal(onSuccess,
            () => Any(
                () => _NestedExpression(SetNode),
                () => _TerminalExpression(SetNode)
            )
        );
    }

    // nested-expression ::= optional-expression @ optional-expression | repetition-expression @ repetition-expression | group-expression @ group-expression ;
    private void _NestedExpression(Action<NestedExpression> onSuccess)
    {
        VirtualNonTerminal(onSuccess,
            () => Any(
                () => _OptionalExpression(SetNode),
                () => _RepetitionExpression(SetNode),
                () => _GroupExpression(SetNode)
            )
        );
    }

    // optional-expression ::= "[" expression @ expression "]" ;
    private void _OptionalExpression(Action<OptionalExpression> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => Terminal("["),
                () => _Expression(r => GetNode<OptionalExpression>().Expression = r),
                () => Terminal("]")
            )
        );
    }

    // repetition-expression ::= "{" expression @ expression "}" ;
    private void _RepetitionExpression(Action<RepetitionExpression> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => Terminal("{"),
                () => _Expression(r => GetNode<RepetitionExpression>().Expression = r),
                () => Terminal("}")
            )
        );
    }

    // group-expression ::= "(" expression @ expression ")" ;
    private void _GroupExpression(Action<GroupExpression> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => Terminal("("),
                () => _Expression(r => GetNode<GroupExpression>().Expression = r),
                () => Terminal(")")
            )
        );
    }

    // terminal-expression ::= identifier-expression @ identifier-expression | string-expression @ string-expression | extractor-expression @ extractor-expression ;
    private void _TerminalExpression(Action<TerminalExpression> onSuccess)
    {
        VirtualNonTerminal(onSuccess,
            () => Any(
                () => _IdentifierExpression(SetNode),
                () => _StringExpression(SetNode),
                () => _ExtractorExpression(SetNode)
            )
        );
    }

    // identifier-expression ::= [ name @ name ] identifier @ identifier ;
    private void _IdentifierExpression(Action<IdentifierExpression> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => Optional(
                    () => _Name(r => GetNode<IdentifierExpression>().Name = r)
                ),
                () => Terminal(Patterns.Identifier, r => GetNode<IdentifierExpression>().Identifier = r)
            )
        );
    }

    // string-expression ::= [ name @ name ] string @ string ;
    private void _StringExpression(Action<StringExpression> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => Optional(
                    () => _Name(r => GetNode<StringExpression>().Name = r)
                ),
                () => Terminal(Patterns.String, r => GetNode<StringExpression>().String = r)
            )
        );
    }

    // extractor-expression ::= [ name @ name ] "/" pattern @ pattern "/" ;
    private void _ExtractorExpression(Action<ExtractorExpression> onSuccess)
    {
        NonTerminal(onSuccess,
            () => All(
                () => Optional(
                    () => _Name(r => GetNode<ExtractorExpression>().Name = r)
                ),
                () => Terminal("/"),
                () => Terminal(Patterns.Pattern, r => GetNode<ExtractorExpression>().Pattern = r),
                () => Terminal("/")
            )
        );
    }

    // name ::= identifier @ identifier "@" ;
    private void _Name(Action<string> onSuccess)
    {
        All(
            () => Terminal(Patterns.Identifier, onSuccess),
            () => Terminal("@")
        );
    }
}
#endregion

#region Visitor
public class Visitor
{
    public void Visit(ISyntaxNode node)
    {
        Visit(node, null);
    }

    protected virtual void Visit(ISyntaxNode node, ISyntaxNode parent)
    {
        node?.Accept(this);
    }

    public virtual void VisitGrammar(Grammar node)
    {
        for (var i = 0; i < node.Rules.Count; i++)
            Visit(node.Rules[i], node);
    }

    public virtual void VisitRule(Rule node)
    {
        Visit(node.Expression, node);
    }

    public virtual void VisitSequentialExpression(SequentialExpression node)
    {
        Visit(node.NonSequentialExpression, node);
        Visit(node.Expression, node);
    }

    public virtual void VisitAlternativesExpression(AlternativesExpression node)
    {
        Visit(node.AtomicExpression, node);
        Visit(node.NonSequentialExpression, node);
    }

    public virtual void VisitOptionalExpression(OptionalExpression node)
    {
        Visit(node.Expression, node);
    }

    public virtual void VisitRepetitionExpression(RepetitionExpression node)
    {
        Visit(node.Expression, node);
    }

    public virtual void VisitGroupExpression(GroupExpression node)
    {
        Visit(node.Expression, node);
    }

    public virtual void VisitIdentifierExpression(IdentifierExpression node)
    {
    }

    public virtual void VisitStringExpression(StringExpression node)
    {
    }

    public virtual void VisitExtractorExpression(ExtractorExpression node)
    {
    }
}
#endregion
