// Given a Parser Model, the Emitter generates CSharp code
// author: Christophe VG <contact@christophe.vg>
// revised by: Adam Simon <adamosimoni@gmail.com> 

using System;
using System.Collections.Generic;
using System.Linq;
using HumanParserGenerator.Generator;
using System.Globalization;
using System.Text;

namespace HumanParserGenerator.Emitter
{
    public class CSharp
    {
        public bool EmitInfo { get; set; }
        public bool EmitRule { get; set; }
        public bool EmitVisitor { get; set; }
        public List<string> Sources { get; set; }
        public string Namespace { get; set; }

        private Model _model;

        public CSharp Generate(Model model)
        {
            _model = model;
            return this;
        }

        public override string ToString()
        {
            var builder = new CodeBuilder();

            if (_model == null)
            {
                builder.AppendIndentedLine("// no model generated");
                return builder.ToString();
            }

            if (_model.Entities.Count == 0)
            {
                builder.AppendIndentedLine("// no entities generated");
                return builder.ToString();
            }

            GenerateHeader(builder);
            GenerateReferences(builder);
            GenerateSyntaxNode(builder);
            GenerateNamespace(builder);
            GenerateEntities(builder);
            GenerateParser(builder);
            GenerateVisitor(builder);
            GenerateFooter(builder);

            return builder.ToString();
        }

        bool IsDerivedConsumePattern(Entity entity)
        {
            // TODO: is this check correct?
            Property property;
            return
                entity.Properties.Count == 1 &&
                ((property = entity.Properties[0]).Type == "<string>" || property.Type == "<bool>");
        }

        private void GenerateHeader(CodeBuilder builder)
        {
            if (EmitInfo)
            {
                var now = DateTime.Now;

                builder.AppendIndentedLine("// DO NOT EDIT THIS FILE");
                builder.AppendIndentedLine("// This file was generated using the Human Parser Generator");
                builder.AppendIndentedLine("// (https://github.com/christophevg/human-parser-generator)");
                builder.AppendIndentedLine($"// on {now.ToString("D", CultureInfo.InvariantCulture)} at {now.ToString("T", CultureInfo.InvariantCulture)}");

                if (Sources != null && Sources.Count > 0)
                    builder.AppendIndentedLine($"// Source{(Sources.Count > 1 ? "s" : null)}: {string.Join(", ", Sources)}");

                builder.AppendLine();
            }
        }

        private void GenerateReferences(CodeBuilder builder)
        {
            builder.AppendIndentedLine("using System;");
            builder.AppendIndentedLine("using System.Collections.Generic;");
            builder.AppendIndentedLine("using System.Text.RegularExpressions;");
            builder.AppendIndentedLine("using System.Linq;");
            builder.AppendIndentedLine("using HumanParserGenerator;");
            builder.AppendLine();
        }

        private void GenerateSyntaxNode(CodeBuilder builder)
        {
            if (EmitVisitor)
            {
                var @namespace = typeof(ISyntaxNode).Namespace;

                if (!string.IsNullOrEmpty(@namespace))
                {
                    builder.AppendIndentedLine($"namespace {@namespace}");
                    builder.AppendBlockStart();
                }

                builder.AppendIndentedLine($"public partial interface {typeof(ISyntaxNode).Name}");
                builder.AppendBlockStart();
                builder.AppendIndentedLine("void Accept(Visitor visitor);");
                builder.AppendBlockEnd(appendEmptyLine: false);

                if (!string.IsNullOrEmpty(@namespace))
                    builder.AppendBlockEnd(appendEmptyLine: false);

                builder.AppendLine();
            }
        }

        private void GenerateNamespace(CodeBuilder builder)
        {
            if (Namespace == null)
                return;

            builder.AppendIndentedLine($"namespace {Namespace}");
            builder.AppendBlockStart();
        }

        private void GenerateEntities(CodeBuilder builder)
        {
            builder.AppendIndentedLine("#region Syntax Tree");

            foreach (var entity in _model.Entities)
                if (!(entity.IsVirtual && entity.ParseAction is ConsumePattern))
                    GenerateEntity(builder, entity);

            builder.RemoveNewLine();

            builder.AppendIndentedLine("#endregion");
            builder.AppendLine();
        }

        private void GenerateEntity(CodeBuilder builder, Entity entity)
        {
            GenerateEntityHeader(builder, entity);
            GenerateEntityProperties(builder, entity);
            GenerateEntityMethods(builder, entity);
            GenerateEntityFooter(builder, entity);
        }

        #region Syntax Tree
        private void GenerateEntityHeader(CodeBuilder builder, Entity entity)
        {
            builder.AppendIndented($"public {(entity.IsVirtual ? "interface" : "class")} {Format.CSharp.Class(entity)} : ");

            builder.AppendLine(string.Join(", ", new[] { typeof(ISyntaxNode).Name }
                .Concat(entity.Supers.Where(s => s.IsVirtual).Select(Format.CSharp.Class))));

            builder.AppendBlockStart();
        }

        private void GenerateEntityProperties(CodeBuilder builder, Entity entity)
        {
            if (entity.IsVirtual)
                return;

            foreach (var property in entity.Properties)
                GenerateProperty(builder, property);
        }

        private void GenerateEntityMethods(CodeBuilder builder, Entity entity)
        {
            if (entity.IsVirtual || !EmitVisitor)
                return;

            builder.AppendLine();

            var entityName = Format.CSharp.Class(entity);

            builder.AppendIndentedLine("public void Accept(Visitor visitor)");
            builder.AppendBlockStart();
            builder.AppendIndentedLine($"visitor.Visit{entityName}(this);");
            builder.AppendBlockEnd(appendEmptyLine: false);
        }

        private void GenerateProperty(CodeBuilder builder, Property property)
        {
            var propertyType = Format.CSharp.Type(property);
            var propertyName = Format.CSharp.Property(property);
            builder.AppendIndented($"public {propertyType} {propertyName} {{ get; set; }}");
            if (property.IsPlural || property.Source.HasPluralParent)
                builder.Append($" = new {propertyType}();");
            builder.AppendLine();
        }

        private void GenerateEntityFooter(CodeBuilder builder, Entity entity)
        {
            builder.AppendBlockEnd();
        }

        #endregion

        #region Parser
        const string PatternsClassName = "Patterns";

        private void GenerateParser(CodeBuilder builder)
        {
            builder.AppendIndentedLine("#region Parser");

            GenerateParserHeader(builder);
            GenerateEntityParsers(builder);
            GenerateParserFooter(builder);

            builder.AppendIndentedLine("#endregion");
            builder.AppendLine();
        }

        private void GenerateParserHeader(CodeBuilder builder)
        {
            builder.AppendIndentedLine($"public sealed class Parser : ParserBase<{Format.CSharp.Class(_model.Root)}>");

            builder.AppendBlockStart();

            if (_model.Contains("_") && _model["_"].ParseAction is ConsumePattern)
            {
                var ignorePattern = Format.CSharp.VerbatimStringLiteral(string.Concat("\\G(", ((ConsumePattern)_model["_"].ParseAction).Pattern));

                builder.AppendIndentedLine($"public Parser() : base({ignorePattern}) {{ }}");
                builder.AppendLine();
            }

            GeneratePatterns(builder);
        }

        // Extracting functionality is generated for all Entities that are "just"
        // consuming a pattern.
        private void GeneratePatterns(CodeBuilder builder)
        {
            builder.AppendIndentedLine($"private static class {PatternsClassName}");
            builder.AppendBlockStart();

            foreach (var entity in _model.Entities)
                if (entity.ParseAction is ConsumePattern consumePattern)
                {
                    var entityName = Format.CSharp.Class(entity);
                    var pattern = Format.CSharp.VerbatimStringLiteral("^" + consumePattern.Pattern);
                    builder.AppendIndentedLine($"public static readonly Regex {entityName} = new Regex({pattern}, RegexOptions.Compiled);");
                }

            builder.AppendBlockEnd();
        }

        private void GenerateEntityParsers(CodeBuilder builder)
        {
            foreach (var entity in _model.Entities)
                if (!(entity.IsVirtual && entity.ParseAction is ConsumePattern))
                    GenerateEntityParser(builder, entity);

            builder.RemoveNewLine();
        }

        private void GenerateEntityParser(CodeBuilder builder, Entity entity)
        {
            GenerateEntityParserHeader(builder, entity);

            builder.AppendIndent();

            Action<CodeBuilder> generator = b => GenerateParseAction(b, entity.ParseAction);

            if (!(entity.ParseAction is ConsumePattern) && !IsDerivedConsumePattern(entity))
            {
                var originalGenerator = generator;
                generator = b => GenerateEntityWrapper(builder, entity, originalGenerator);
            }

            generator(builder);

            builder.AppendLine(";");

            GenerateEntityParserFooter(builder, entity);
        }

        private void GenerateEntityParserHeader(CodeBuilder builder, Entity entity)
        {
            var modifiers = entity.IsRoot ? "protected override" : "private";
            var methodName = GetEntityMethodName(entity);

            var resultTypeName = !IsDerivedConsumePattern(entity) ? Format.CSharp.Class(entity) : "string";

            GenerateRule(builder, entity.Rule);
            builder.AppendIndentedLine($"{modifiers} void {methodName}(Action<{resultTypeName}> onSuccess)");

            builder.AppendBlockStart();
        }

        private void GenerateEntityWrapper(CodeBuilder builder, Entity entity, Action<CodeBuilder> generator)
        {
            if (entity.IsVirtual)
                builder.Append("VirtualNonTerminal");
            else
                builder.Append("NonTerminal");

            builder.AppendLine("(onSuccess,");

            builder.Indent();

            builder.AppendIndented("() => ");

            generator(builder);

            builder.AppendLine();

            builder.Unindent();
            builder.AppendIndented(")");
        }

        string GetEntityMethodName(Entity entity)
        {
            return entity.IsRoot ? "Root" : "_" + Format.CSharp.Class(entity);
        }

        private Action<CodeBuilder> GetParseActionGenerator(ParseAction action)
        {
            switch (action)
            {
                case ConsumePattern consumePattern:
                    return builder => GenerateConsumePattern(builder, consumePattern);
                case ConsumeString consumeString:
                    return builder => GenerateConsumeString(builder, consumeString);
                case ConsumeEntity consumeEntity:
                    return builder => GenerateConsumeEntity(builder, consumeEntity);
                case ConsumeAny consumeAny:
                    return builder => GenerateConsumeComposite(builder, "Any", consumeAny);
                case ConsumeAll consumeAll:
                    return builder => GenerateConsumeComposite(builder, "All", consumeAll);
                default:
                    throw new NotSupportedException("Unsupported parse action.");
            }
        }

        private void GenerateParseAction(CodeBuilder builder, ParseAction action)
        {
            var generator = GetParseActionGenerator(action);

            if (action.IsPlural)
            {
                var originalGenerator = generator;
                generator = b => GenerateConsumeWrapper(b, "Plural", originalGenerator);
            }

            if (action.IsOptional)
            {
                var originalGenerator = generator;
                generator = b => GenerateConsumeWrapper(b, "Optional", originalGenerator);
            }

            generator(builder);
        }

        private void GenerateConsumeWrapper(CodeBuilder builder, string methodName, Action<CodeBuilder> generator)
        {
            builder.Append(methodName);
            builder.AppendLine("(");
            builder.Indent();

            builder.AppendIndented("() => ");
            generator(builder);
            builder.AppendLine();

            builder.Unindent();
            builder.AppendIndented(")");
        }

        private void GenerateConsumeString(CodeBuilder builder, ConsumeString action)
        {
            builder.Append($"Terminal(\"{action.String}\"");

            if (action.Property != null && action.Parent is ConsumeAny)
            {
                builder.Append(", r => ");
                builder.Append(BuildSetter(action));
            }

            builder.Append($")");

            string BuildSetter(ConsumeString a)
            {
                var propertyEntityName = Format.CSharp.Class(a.Property.Entity);
                var propertyName = Format.CSharp.Property(a.Property);

                return
                    a.Property.IsPlural || a.Property.Source.HasPluralParent ?
                    $"GetNode<{propertyEntityName}>().{propertyName}.Add(r)" :
                    $"GetNode<{propertyEntityName}>().{propertyName} = r";
            }
        }

        private void GenerateConsumePattern(CodeBuilder builder, ConsumePattern action)
        {
            var entityName = Format.CSharp.Class(action.Property.Entity);

            builder.Append($"Terminal({PatternsClassName}.{entityName}, (n, v) => {BuildSetter(action)}, onSuccess)");

            string BuildSetter(ConsumePattern a)
            {
                if (a.Property == null)
                    return "{ }";

                var propertyName = Format.CSharp.Property(a.Property);
                return $"n.{propertyName} = v";
            }
        }

        private void GenerateConsumeEntity(CodeBuilder builder, ConsumeEntity action)
        {
            var entityName = Format.CSharp.Class(action.Entity);
            var methodName = GetEntityMethodName(action.Entity);

            if (action.Entity.IsVirtual && action.Entity.ParseAction is ConsumePattern consumePattern)
                builder.Append($"Terminal({PatternsClassName}.{entityName}, {BuildSetter(action)})");
            else
                builder.Append($"{methodName}({BuildSetter(action)})");

            string BuildSetter(ConsumeEntity a)
            {
                if (a.Property == null)
                    return "r => { }";

                if (a.Property.Entity.IsVirtual)
                    return !(a.Entity.IsVirtual && a.Entity.ParseAction is ConsumePattern) ? "SetNode" : "onSuccess";

                var propertyEntityName = Format.CSharp.Class(a.Property.Entity);
                var propertyName = Format.CSharp.Property(a.Property);

                return
                    a.Property.IsPlural || a.Property.Source.HasPluralParent ?
                    $"r => GetNode<{propertyEntityName}>().{propertyName}.Add(r)" :
                    $"r => GetNode<{propertyEntityName}>().{propertyName} = r";
            }
        }

        private void GenerateConsumeComposite(CodeBuilder builder, string methodName, ConsumeAll action)
        {
            builder.Append(methodName);
            builder.AppendLine("(");
            builder.Indent();

            var n = action.Actions.Count;
            for (var i = 0; i < n - 1; i++)
            {
                builder.AppendIndented("() => ");
                GenerateParseAction(builder, action.Actions[i]);
                builder.AppendLine(",");
            }

            builder.AppendIndented("() => ");
            GenerateParseAction(builder, action.Actions[n - 1]);
            builder.AppendLine();

            builder.Unindent();
            builder.AppendIndented(")");
        }

        private void GenerateEntityParserFooter(CodeBuilder builder, Entity entity)
        {
            builder.AppendBlockEnd();
        }

        private void GenerateParserFooter(CodeBuilder builder)
        {
            builder.AppendBlockEnd(appendEmptyLine: false);
        }

        #endregion

        #region Visitor
        private void GenerateVisitor(CodeBuilder builder)
        {
            if (!EmitVisitor)
                return;

            builder.AppendIndentedLine("#region Visitor");

            GenerateVisitorHeader(builder);
            GenerateVisitorBody(builder);
            GenerateVisitorFooter(builder);

            builder.AppendIndentedLine("#endregion");
            builder.AppendLine();
        }

        private void GenerateVisitorHeader(CodeBuilder builder)
        {
            builder.AppendIndentedLine($"public class Visitor");

            builder.AppendBlockStart();
        }

        private void GenerateVisitorBody(CodeBuilder builder)
        {
            builder.AppendIndentedLine("public void Visit(ISyntaxNode node)");
            builder.AppendBlockStart();
            builder.AppendIndentedLine("Visit(node, null);");
            builder.AppendBlockEnd();

            builder.AppendIndentedLine("protected virtual void Visit(ISyntaxNode node, ISyntaxNode parent)");
            builder.AppendBlockStart();
            builder.AppendIndentedLine("node?.Accept(this);");
            builder.AppendBlockEnd();

            foreach (var entity in _model.Entities)
                if (!entity.IsVirtual)
                    GenerateEntityVisit(builder, entity);

            builder.RemoveNewLine();
        }

        private void GenerateEntityVisit(CodeBuilder builder, Entity entity)
        {
            var entityName = Format.CSharp.Class(entity);

            builder.AppendIndentedLine($"public virtual void Visit{entityName}({entityName} node)");
            builder.AppendBlockStart();

            foreach (var property in entity.Properties)
                if (!(property.Entity.ParseAction is ConsumePattern) && property.Type != "<string>" && property.Type != "<bool>")
                    GeneratePropertyVisit(builder, property);

            builder.AppendBlockEnd();
        }

        private void GeneratePropertyVisit(CodeBuilder builder, Property property)
        {
            var propertyName = Format.CSharp.Property(property);

            if (property.IsPlural || property.Source.HasPluralParent)
            {
                builder.AppendIndentedLine($"for (var i = 0; i < node.{propertyName}.Count; i++)");
                builder.Indent();
                builder.AppendIndentedLine($"Visit(node.{propertyName}[i], node);");
                builder.Unindent();
            }
            else
                builder.AppendIndentedLine($"Visit(node.{propertyName}, node);");
        }

        private void GenerateVisitorFooter(CodeBuilder builder)
        {
            builder.AppendBlockEnd(appendEmptyLine: false);
        }

        #endregion

        private void GenerateFooter(CodeBuilder builder)
        {
            if (Namespace != null)
                builder.AppendBlockEnd(appendEmptyLine: false);

            builder.RemoveNewLine();
        }

        private Emitter.BNF _bnf = new Emitter.BNF();

        private void GenerateRule(CodeBuilder builder, Rule rule)
        {
            if (!EmitRule)
                return;

            builder.AppendIndentedLine("// " + _bnf.GenerateRule(rule));
        }

        // logging functionality

        private void Warn(string msg)
        {
            Log("warning: " + msg);
        }

        private void Log(string msg)
        {
            Console.Error.WriteLine("hpg-emitter: " + msg);
        }
    }
}
