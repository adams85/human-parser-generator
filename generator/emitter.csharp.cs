// Given a Parser Model, the Emitter generates CSharp code
// author: Christophe VG <contact@christophe.vg>
// revised by: Adam Simon <adamosimoni@gmail.com> 

using System;
using System.Collections.Generic;
using System.Linq;
using HumanParserGenerator.Generator;
using System.Globalization;
using System.Text;

namespace HumanParserGenerator.Emitter
{
    public class CSharp
    {
        class Builder
        {
            int _indentLevel;

            public Builder()
            {
                StringBuilder = new StringBuilder();
            }

            public StringBuilder StringBuilder { get; }

            public void Indent()
            {
                _indentLevel++;
            }

            public void Unindent()
            {
                _indentLevel--;
            }

            public void AppendIndent()
            {
                for (var i = 0; i < _indentLevel; i++)
                    StringBuilder.Append("    ");
            }

            public void AppendIndented(string value)
            {
                AppendIndent();
                StringBuilder.Append(value);
            }

            public void AppendIndentedLine(string value)
            {
                AppendIndent();
                StringBuilder.AppendLine(value);
            }

            public void AppendBlockStart()
            {
                AppendIndentedLine("{");
                Indent();
            }

            public void AppendBlockEnd()
            {
                Unindent();
                AppendIndentedLine("}");
                StringBuilder.AppendLine();
            }

            public void AppendLine()
            {
                StringBuilder.AppendLine();
            }

            public void AppendLine(string value)
            {
                StringBuilder.AppendLine(value);
            }

            public void Append(string value)
            {
                StringBuilder.Append(value);
            }

            public override string ToString()
            {
                return StringBuilder.ToString();
            }
        }

        public bool EmitInfo { get; set; }
        public bool EmitRule { get; set; }
        public bool EmitVisitor { get; set; }
        public List<string> Sources { get; set; }
        public string Namespace { get; set; }

        private Model _model;

        public CSharp Generate(Model model)
        {
            _model = model;
            return this;
        }

        public override string ToString()
        {
            var builder = new Builder();

            if (_model == null)
            {
                builder.AppendIndentedLine("// no model generated");
                return builder.ToString();
            }

            if (_model.Entities.Count == 0)
            {
                builder.AppendIndentedLine("// no entities generated");
                return builder.ToString();
            }

            GenerateHeader(builder);
            GenerateReferences(builder);
            GenerateNamespace(builder);
            GenerateEntities(builder);
            GenerateParser(builder);
            GenerateFooter(builder);

            return builder.ToString();
        }

        private void GenerateHeader(Builder builder)
        {
            if (EmitInfo)
            {
                var now = DateTime.Now;

                builder.AppendIndentedLine("// DO NOT EDIT THIS FILE");
                builder.AppendIndentedLine("// This file was generated using the Human Parser Generator");
                builder.AppendIndentedLine("// (https://github.com/christophevg/human-parser-generator)");
                builder.AppendIndentedLine($"// on {now.ToString("D", CultureInfo.InvariantCulture)} at {now.ToString("T", CultureInfo.InvariantCulture)}");

                if (Sources != null && Sources.Count > 0)
                    builder.AppendIndentedLine($"// Source{(Sources.Count > 1 ? "s" : null)}: {string.Join(", ", Sources)}");

                builder.AppendLine();
            }
        }

        private void GenerateReferences(Builder builder)
        {
            builder.AppendIndentedLine("using System;");
            builder.AppendIndentedLine("using System.IO;");
            builder.AppendIndentedLine("using System.Collections.Generic;");
            builder.AppendIndentedLine("using System.Text.RegularExpressions;");
            builder.AppendIndentedLine("using System.Linq;");
            builder.AppendLine();
        }

        private void GenerateNamespace(Builder builder)
        {
            if (Namespace == null)
                return;

            builder.AppendIndentedLine($"namespace {Namespace}");
            builder.AppendBlockStart();
        }

        private void GenerateEntities(Builder builder)
        {
            builder.AppendIndentedLine("#region Syntax Tree");

            if (EmitVisitor)
            {
                builder.AppendIndentedLine("public partial interface ISyntaxNode");
                builder.AppendBlockStart();
                builder.AppendIndentedLine("void Accept(Visitor visitor);");
                builder.AppendBlockEnd();
            }

            foreach (var entity in _model.Entities)
                if (!(entity.IsVirtual && entity.ParseAction is ConsumePattern))
                    GenerateEntity(builder, entity);

            builder.AppendIndentedLine("#endregion");
            builder.AppendLine();
        }

        private void GenerateEntity(Builder builder, Entity entity)
        {
            GenerateEntityHeader(builder, entity);
            GenerateProperties(builder, entity);
            GenerateEntityFooter(builder, entity);
        }

        #region Syntax Tree
        private void GenerateEntityHeader(Builder builder, Entity entity)
        {
            builder.AppendIndented($"public {(entity.IsVirtual ? "interface" : "class")} {Format.CSharp.Class(entity)} : ");

            builder.AppendLine(string.Join(", ", new[] { "ISyntaxNode" /* TODO */ }
                .Concat(entity.Supers.Where(s => s.IsVirtual).Select(Format.CSharp.Class))));

            builder.AppendBlockStart();
        }

        private void GenerateProperties(Builder builder, Entity entity)
        {
            if (entity.IsVirtual)
                return;

            foreach (var property in entity.Properties)
                GenerateProperty(builder, property);
        }

        private void GenerateProperty(Builder builder, Property property)
        {
            var propertyType = Format.CSharp.Type(property);
            var propertyName = Format.CSharp.Property(property);
            builder.AppendIndented($"public {propertyType} {propertyName} {{ get; set; }}");
            if (property.IsPlural || property.Source.HasPluralParent)
                builder.Append($" = new {propertyType}();");
            builder.AppendLine();
        }

        private void GenerateEntityFooter(Builder builder, Entity entity)
        {
            builder.AppendBlockEnd();
        }

        #endregion

        #region Parser
        const string PatternsClassName = "Patterns";

        private void GenerateParser(Builder builder)
        {
            builder.AppendIndentedLine("#region Parser");

            GenerateParserHeader(builder);
            GenerateEntityParsers(builder);
            GenerateParserFooter(builder);

            builder.AppendIndentedLine("#endregion");
            builder.AppendLine();
        }

        // Extracting functionality is generated for all Entities that are "just"
        // consuming a pattern.
        private void GeneratePatterns(Builder builder)
        {
            builder.AppendIndentedLine($"private static class {PatternsClassName}");
            builder.AppendBlockStart();

            foreach (var entity in _model.Entities)
                if (entity.ParseAction is ConsumePattern consumePattern)
                {
                    var entityName = Format.CSharp.Class(entity);
                    var pattern = Format.CSharp.VerbatimStringLiteral("^" + consumePattern.Pattern);
                    builder.AppendIndentedLine($"public static readonly Regex {entityName} = new Regex({pattern}, RegexOptions.Compiled);");
                }

            builder.AppendBlockEnd();
        }

        private void GenerateParserHeader(Builder builder)
        {
            builder.AppendIndentedLine($"public sealed class Parser : ParserBase<{Format.CSharp.Class(_model.Root)}>");

            builder.AppendBlockStart();

            if (_model.Contains("_") && _model["_"].ParseAction is ConsumePattern)
            {
                var ignorePattern = Format.CSharp.VerbatimStringLiteral(string.Concat("\\G(", ((ConsumePattern)_model["_"].ParseAction).Pattern));

                builder.AppendIndentedLine($"public Parser() : base({ignorePattern}) {{ }}");
                builder.AppendLine();
            }

            GeneratePatterns(builder);
        }

        private void GenerateEntityParsers(Builder builder)
        {
            foreach (var entity in _model.Entities)
                if (!(entity.IsVirtual && entity.ParseAction is ConsumePattern))
                    GenerateEntityParser(builder, entity);
        }

        private void GenerateEntityParser(Builder builder, Entity entity)
        {
            GenerateEntityParserHeader(builder, entity);

            builder.AppendIndent();

            Action<Builder> generator = b => GenerateParseAction(b, entity.ParseAction);

            
            if (!(entity.ParseAction is ConsumePattern) &&
                // TODO: is this check correct? simpler solution?
                !(entity.Properties.Count == 1 && 
                entity.Properties[0].Source is ConsumeEntity consumeEntity &&
                consumeEntity.Entity.ParseAction is ConsumePattern))
            {
                var originalGenerator = generator;
                generator = b => GenerateEntityWrapper(builder, entity, originalGenerator);
            }

            generator(builder);

            builder.AppendLine(";");

            GenerateEntityParserFooter(builder, entity);
        }

        private void GenerateEntityParserHeader(Builder builder, Entity entity)
        {
            var modifiers = entity.IsRoot ? "protected override" : "private";
            var methodName = GetEntityMethodName(entity);

            var resultTypeName =
                // TODO: is this check correct? simpler solution?
                !(entity.Properties.Count == 1 &&
                    entity.Properties[0].Source is ConsumeEntity consumeEntity &&
                    consumeEntity.Entity.ParseAction is ConsumePattern) ?
                Format.CSharp.Class(entity) :
                "string";

            GenerateRule(builder, entity.Rule);
            builder.AppendIndentedLine($"{modifiers} void {methodName}(Action<{resultTypeName}> onSuccess)");

            builder.AppendBlockStart();
        }

        private void GenerateEntityWrapper(Builder builder, Entity entity, Action<Builder> generator)
        {
            if (entity.IsVirtual)
                builder.Append("VirtualNonTerminal");
            else
                builder.Append("NonTerminal");

            builder.AppendLine("(onSuccess,");

            builder.Indent();

            builder.AppendIndented("() => ");

            generator(builder);

            builder.AppendLine();

            builder.Unindent();
            builder.AppendIndented(")");
        }

        string GetEntityMethodName(Entity entity)
        {
            return entity.IsRoot ? "Root" : "_" + Format.CSharp.Class(entity);
        }

        private Action<Builder> GetParseActionGenerator(ParseAction action)
        {
            switch (action)
            {
                case ConsumePattern consumePattern:
                    return builder => GenerateConsumePattern(builder, consumePattern);
                case ConsumeString consumeString:
                    return builder => GenerateConsumeString(builder, consumeString);
                case ConsumeEntity consumeEntity:
                    return builder => GenerateConsumeEntity(builder, consumeEntity);
                case ConsumeAny consumeAny:
                    return builder => GenerateConsumeComposite(builder, "Any", consumeAny);
                case ConsumeAll consumeAll:
                    return builder => GenerateConsumeComposite(builder, "All", consumeAll);
                default:
                    throw new NotSupportedException("Unsupported parse action.");
            }
        }

        private void GenerateParseAction(Builder builder, ParseAction action)
        {
            var generator = GetParseActionGenerator(action);

            if (action.IsPlural)
            {
                var originalGenerator = generator;
                generator = b => GenerateConsumeWrapper(b, "Plural", originalGenerator);
            }

            if (action.IsOptional)
            {
                var originalGenerator = generator;
                generator = b => GenerateConsumeWrapper(b, "Optional", originalGenerator);
            }

            generator(builder);
        }

        private void GenerateConsumeWrapper(Builder builder, string methodName, Action<Builder> generator)
        {
            builder.Append(methodName);
            builder.AppendLine("(");
            builder.Indent();

            builder.AppendIndented("() => ");
            generator(builder);
            builder.AppendLine();

            builder.Unindent();
            builder.AppendIndented(")");
        }

        private void GenerateConsumeString(Builder builder, ConsumeString action)
        {
            builder.Append($"Terminal(\"{action.String}\")");
        }

        private void GenerateConsumePattern(Builder builder, ConsumePattern action)
        {
            var entityName = Format.CSharp.Class(action.Property.Entity);

            builder.Append($"Terminal({PatternsClassName}.{entityName}, (n, v) => {BuildSetter(action)}, onSuccess)");

            string BuildSetter(ConsumePattern a)
            {
                if (a.Property == null)
                    return "{ }";

                var propertyName = Format.CSharp.Property(a.Property);
                return $"n.{propertyName} = v";
            }
        }

        private void GenerateConsumeEntity(Builder builder, ConsumeEntity action)
        {
            var entityName = Format.CSharp.Class(action.Entity);
            var methodName = GetEntityMethodName(action.Entity);

            if (action.Entity.IsVirtual && action.Entity.ParseAction is ConsumePattern consumePattern)
                builder.Append($"Terminal({PatternsClassName}.{entityName}, {BuildSetter(action)})");
            else
                builder.Append($"{methodName}({BuildSetter(action)})");

            string BuildSetter(ConsumeEntity a)
            {
                if (a.Property == null)
                    return "{ }";

                if (a.Property.Entity.IsVirtual)
                    return !(a.Entity.IsVirtual && a.Entity.ParseAction is ConsumePattern) ? "SetNode" : "onSuccess";

                var propertyEntityName = Format.CSharp.Class(a.Property.Entity);
                var propertyName = Format.CSharp.Property(a.Property);

                return
                    a.Property.IsPlural || a.Property.Source.HasPluralParent ?
                    $"r => GetNode<{propertyEntityName}>().{propertyName}.Add(r)" :
                    $"r => GetNode<{propertyEntityName}>().{propertyName} = r";
            }
        }

        private void GenerateConsumeComposite(Builder builder, string methodName, ConsumeAll action)
        {
            builder.Append(methodName);
            builder.AppendLine("(");
            builder.Indent();

            var n = action.Actions.Count;
            for (var i = 0; i < n - 1; i++)
            {
                builder.AppendIndented("() => ");
                GenerateParseAction(builder, action.Actions[i]);
                builder.AppendLine(",");
            }

            builder.AppendIndented("() => ");
            GenerateParseAction(builder, action.Actions[n - 1]);
            builder.AppendLine();

            builder.Unindent();
            builder.AppendIndented(")");
        }

        private void GenerateEntityParserFooter(Builder builder, Entity entity)
        {
            builder.AppendBlockEnd();
        }

        private void GenerateParserFooter(Builder builder)
        {
            builder.AppendBlockEnd();
        }

        #endregion

        private void GenerateFooter(Builder builder)
        {
            if (Namespace != null)
                builder.AppendBlockEnd();
        }

        private Emitter.BNF _bnf = new Emitter.BNF();

        private void GenerateRule(Builder builder, Rule rule)
        {
            if (!EmitRule)
                return;

            builder.AppendIndentedLine("// " + _bnf.GenerateRule(rule));
        }

        // logging functionality

        private void Warn(string msg)
        {
            Log("warning: " + msg);
        }

        private void Log(string msg)
        {
            Console.Error.WriteLine("hpg-emitter: " + msg);
        }
    }
}
